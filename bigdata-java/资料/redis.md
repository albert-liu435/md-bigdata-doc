## 缓存雪崩、缓存穿透、缓存预热、缓存降级等问题

### 缓存雪崩

大量的key设置了相同的过期时间，导致缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。

我们可以简单的理解为：由于原有缓存失效，新缓存未设置的期间（例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期），所有本应该访问缓存的请求都去查询数据库了，导致数据库的CPU和内存压力陡增，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。

##### **解决办法：**

不同种类的缓存数据设置不同长度的过期时间，将缓存失效时间分散开 采用加锁或者队列的方式来保证不会有大量线程对数据库一次性进行读写，从而避免缓存失效时大量的并发请求落到数据库上。

缓存雪崩有三种解决方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间。

### 缓存穿透

缓存穿透是指用户查询请求的数据，在数据库中没有，自然在缓存中也没有。这样就导致用户查询的时候，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存，直接查询数据库，这也是经常提到的缓存命中率的问题。

##### **解决办法：**

最常见的是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层数据库的查询压力。

另外也有一个简单粗暴的办法，如果一个查询返回的数据为空，仍然把这个空结果进行缓存，但过期时间设置很短（两三分钟）。通过这个直接设置的默认值存放到缓存中，这样第二次缓存中就能获取到值，而不会继续访问数据库 ————————————————