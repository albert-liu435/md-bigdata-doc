# Redis

## Redis的各种部署原理及优缺点

[参考博客](https://blog.csdn.net/joker_187/article/details/103069256)

[博客](https://blog.csdn.net/fedorafrog/category_9526574.html)

#### 单机部署

**优势**：配置简单容易维护；
**劣势**：容易发生单点故障（数据存在一台服务器上，如果这台服务器硬盘发生故障，会发生数据丢失情况），没有容灾措施；单个服务器存储容量有限；

#### 主从复制部署

原理：
通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失数据，为了避免单点故障，通常的做法是将数据复制多个副本以部署在不同的服务器上。为此Redis提供了复制的功能，可以实现一台Redis服务器数据更新后，自动更新新数据到其他Redis服务器上。

在主从模式中，Redis实例分为两种：
主数据库（master）：可以进行读写操作，当写操作导致数据库变化时，主动同步数据到从库。
从数据库（slave）：一般是只读的，并接受主库同步过来的数据。

优势：可以实现读写分离，缓解master的压力，提升系统性能。
劣势：master只有一台，一旦发生单点故障，可能会引起数据不一致问题（同步过程中故障了

#### 哨兵模式部署

**原理：**
故名思义，哨兵的作用就是监控Redis系统的运行状态；
它有两个功能：

- 监控主库和从库是否运行正常。

- 主库发生故障时，自动将从库转换成新的主库。

  ![20191114165907583](.\redis\20191114165907583.png)

  为了保证系统的高可用甚至可以部署多个哨兵，哨兵之间也可以互相监控。

  ![20191114171346941](.\redis\20191114171346941.png)

  **优势**：哨兵在主从的基础之上，提升了系统的可用性。
  **劣势**：还是只有一个写服务器，在高写入的场景会有性能瓶颈；每个库都存了相同的内容，浪费内存。
  
  哨兵+主从并**不能保证数据不丢失**，但是可以保证集群的**高可用**。
  
  - 集群监控：负责监控 Redis master 和 slave 进程是否正常工作。
  - 消息通知：如果某个 **Redis** 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
  - 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
  - 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

#### 集群部署

![20191115152634247](.\redis\20191115152634247.png)

###### 数据的分片存储

Redis集群引入了哈希槽的概念，一个Redis集群有16383个槽。
上图中有3个master服务器分别负责一个槽的子集。

模拟一个增加key的过程：

客户端请求redis
根据公式HASH_SLOT=CRC16(key) mod 16384计算出key属于哪个槽。
根据计算出的结果，指定一个master服务器进行读写操作
同理读的过程也是一样

###### 集群的高可用性

每个集群中的节点都必须打开两个TCP通道。

一个用于服务与客户端之间的通信，如6379
一个用于集群总线，即使用二进制协议的节点到节点通信通道，一般以客户端通信端口加10000，如16379。
节点将群集总线用于故障检测，配置更新，故障转移授权等。
上图中，每个master节点都配置了一个slave节点，一旦其中某一台master离线了，集群将自动提升slave为master。如果主从都fail了，就GG了，所以可以多配置几台slave，提升可用性。

###### 扩展性

如果要添加新节点master4，则需要将一些哈希槽从节点master1，master2，master3移至master4。类似地，如果要从群集中删除节点master1，则可以仅移动master1提供的哈希槽到master2和master3。当节点master1为空时，我可以将其从群集中完全删除。

因为将哈希槽从一个节点移动到另一个节点不需要停止操作，所以添加和删除节点或更改节点持有的哈希槽的百分比不需要任何停机时间。

 ## Redis持久化机制

[参考](https://blog.csdn.net/j1231230/article/details/106329071)

#### RDB（Redis DataBase）持久化方式

是指用数据集快照的方式半持久化模式，记录redis数据库的所有键值对，在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。

##### 机制

###### save机制

阻塞Redis的服务器进程，直到RDB文件被创建完毕。SAVE命令很少被使用，因为其会阻塞主线程来保证快照的写入，而Redis是使用一个主线程来接收所有客户端请求，这样会阻塞所有客户端请求

###### bgsave机制

该指令会fork出一个子进程来创建rdb文件，不阻塞服务器进程，子进程接收请求并创建快照，父进程继续接收客户端的请求

子进程完成文件的创建后会向父进程发送信号，父进程在接收客户端请求的同时，在一定时间间隔内，通过轮询来接收子进程的信号。

###### 自动化触发RDB持久化机制

自动触发是由配置文件来完成的，在 redis.conf 配置文件中进行设置：

**save**：用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如 save m n 。表示m秒内数据修改n次时，自动触发bgsave机制。

##### 优点：

1、完全备份，不同时间的数据集备份可以做到多版本恢复。

2、对性能影响最小，如上文所述，Redis在保存RDB快照时会fork()出子进程来进行，几乎不影响Redis处理客户端请求的效率。

3、RDB文件为二进制文件，方便网络传输，适合灾难恢复。

4、恢复大数据集速度较AOF快。

##### 缺点：

1、可能会丢失最近写入，修改而未能持久化的数据。

2、如果数据集较大且CPU不够强，在fork()子进程时会非常耗时，可能会出现毫秒级不能响应客户端请求的情况。

#### AOF（Append-Only File）持久化方式

采用AOF持久方式时，Redis会把所有写操作记录在一个AOF日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。

###### 优点：

1、安全：若开启always，不会丢失任何数据；若开启everysec，最多也就丢失一秒的数据；

2、提供重写机制：优化AOF文件；

3、可恢复性：如果出现误操作（比如flushall等），只要AOF未被重写，停止服务移除AOF文件中的该语句即可。

4、AOF文件在发生断电等问题时也不会损坏，即使出现某条日志只写了一半的情况，也可以使用redis-check-aof工具进行修复。


###### 缺点：

1、相同的数据集，AOF文件体积较RDB文件大了许多。

2、恢复数据库速度比RDB慢。

3、性能消耗比RDB高。

#### RDB-AOF混合持久化方式

redis4.0之后推出了此种持久化方式，使用RDB作为全量备份，AOF作为增量备份，并且将此种方式作为默认方式使用。

在上述两种方式中，RDB方式是将全量数据写入RDB文件，这样写入的特点是文件小，恢复快，但无法保存最近一次快照之后的数据，AOF则将redis指令存入文件中，这样又会造成文件体积大，恢复时间长等弱点。

在RDB-AOF方式下，持久化策略首先将缓存中的数据以RDB方式全量写入文件，再将写入后新增的数据以AOF的方式追加在RDB数据的后面，在下一次做RDB持久化的时候将AOF的数据重新以RDB的形式写入文件。

这种方式既可以提高读写和恢复效率，也可以减少文件大小，同时可以保证数据的完整性。在此种策略的持久化过程中，子进程会通过管道从父进程读取增量数据；在以RDB格式保存全量数据时，也会通过管道读取数据，不会造成管道的阻塞。采用此种方式下生成的持久化文件，前半段是RDB格式的全量数据，后半段是AOF格式的增量数据。

RDB-AOF混合持久化方式是目前较为推荐的一种持久化方式。


## 缓存雪崩、缓存穿透、缓存预热、缓存降级等问题

[参考](https://blog.csdn.net/fedorafrog/article/details/103157219)

[参考2](https://blog.csdn.net/j1231230/article/details/105248063)

#### 缓存雪崩

大量的key设置了相同的过期时间，导致缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。

我们可以简单的理解为：由于原有缓存失效，新缓存未设置的期间（例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期），所有本应该访问缓存的请求都去查询数据库了，导致数据库的CPU和内存压力陡增，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。

##### **解决办法：**

不同种类的缓存数据设置不同长度的过期时间，将缓存失效时间分散开
采用加锁或者队列的方式来保证不会有大量线程对数据库一次性进行读写，从而避免缓存失效时大量的并发请求落到数据库上。

缓存雪崩有三种解决方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间。

#### 缓存击穿

一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。

##### 解决方案

**(1) 设置热点数据永远不过期；**

**（2）加互斥锁；**

多个线程同时去查询数据库，可以在第一个查询数据的线程里用一个互斥锁来上锁，其他线程走到这一步拿不到锁就等着，等第一个线程查询结束了，然后加入缓存，后面的线程进来发现有缓存了就直接走缓存。

#### 缓存穿透

缓存穿透是指用户查询请求的数据，在数据库中没有，自然在缓存中也没有。这样就导致用户查询的时候，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存，直接查询数据库，这也是经常提到的缓存命中率的问题。

##### **解决办法：**

最常见的是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层数据库的查询压力。

另外也有一个简单粗暴的办法，如果一个查询返回的数据为空，仍然把这个空结果进行缓存，但过期时间设置很短（两三分钟）。通过这个直接设置的默认值存放到缓存中，这样第二次缓存中就能获取到值，而不会继续访问数据库
————————————————

#### 缓存预热

缓存预热这个应该是一个比较常见的概念。系统上线后，将相关缓存数据直接加载到缓存系统。这样就可以避免用户请求时先查询数据库，然后再将数据缓存的问题。

##### **解决办法：**

1. 直接写个缓存刷新页面，上线时手工操作一下
2. 数据量不大，可以在项目启动的时候自动进行加载
3. 定时刷新缓存

#### 缓存降级

缓存降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。

## Redis过期策略以及淘汰策略

#### [过期策略](https://www.cnblogs.com/ysocean/p/12422635.html)

　通常删除某个key，我们有如下三种方式进行处理。

###### 定时删除

　　在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。

　　优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。

　　缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。

###### 惰性删除

　　设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。

　　优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。

　　缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。

###### 定期删除

　　每隔一段时间，我们就对一些key进行检查，删除里面过期的key。

　　优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。

　　缺点：难以确定删除操作执行的时长和频率。

　　　　　如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。

　　　　　如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。

　　　　　另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。

#### Redis的过期策略

前面讨论了删除过期键的三种策略，发现单一使用某一策略都不能满足实际需求，聪明的你可能想到了，既然单一策略不能满足，那就组合来使用吧。

　　没错，Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用。

　　**惰性删除**：Redis的惰性删除策略由 db.c/expireIfNeeded 函数实现，所有键读写命令执行之前都会调用 expireIfNeeded 函数对其进行检查，如果过期，则删除该键，然后执行键不存在的操作；未过期则不作操作，继续执行原有的命令。

　　**定期删除**：由redis.c/activeExpireCycle 函数实现，函数以一定的频率运行，每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。

　　注意：并不是一次运行就检查所有的库，所有的键，而是随机检查一定数量的键。

　　定期删除函数的运行频率，在Redis2.6版本中，规定每秒运行10次，大概100ms运行一次。在Redis2.8版本后，可以通过修改配置文件redis.conf 的 **hz** 选项来调整这个次数。



#### [Redis内存淘汰策略](https://blog.csdn.net/fedorafrog/article/details/103157219)

　　当现有内存大于 maxmemory 时，便会触发redis主动淘汰内存方式，通过设置 maxmemory-policy ，有如下几种淘汰方式：

　　1）volatile-lru  利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) 。

　　2）**allkeys-lru**  利用LRU算法移除任何key （和上一个相比，删除的key包括设置过期时间和不设置过期时间的）。**通常使用该方式**。

　　3）volatile-random 移除设置过过期时间的随机key 。

　　4）allkeys-random 无差别的随机移除。

　　5）volatile-ttl  移除即将过期的key(minor TTL) 

　　6）noeviction 不移除任何key，只是返回一个写错误 ，**默认选项，一般不会选用。**

## Redis分布式锁

使用setnx命令设置一个值，并设置过期时间即可实现分布式锁

#### Redis分布式锁的实现

**分布式锁**是控制分布式系统之间共同访问共享资源的一种锁的实现。如果一个系统，或者不同系统的不同主机之间共享某个资源时，往往需要**互斥**，来排除干扰，满足**数据一致性**

分布式锁需要解决的问题如下：

互斥性：任意时刻只有一个客户端获取到锁，不能有两个客户端同时获取到锁。

安全性：锁只能被持有该锁的客户端删除，不能由其它客户端删除。

死锁：获取锁的客户端因为某些原因而宕机继而无法释放锁，其它客户端再也无法获取锁而导致死锁，此时需要有特殊机制来避免死锁。

容错：当各个节点，如某个redis节点宕机的时候，客户端仍然能够获取锁或释放锁。

#### 常见分布式锁方案对比



| 分类               | 方案                              | 实现原理                                                     | 优点                                                         | 缺点                                                         |
| ------------------ | --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 基于数据库         | 基于mysql表唯一索引               | 1.表增加唯一索引<br/>2.加锁：执行insert语句，若报错，则表明加锁失败<br/>3.解锁：执行delete语句 | 完全利用DB现有能力，实现简单                                 | 1.锁无超时自动失效机制，有死锁风险<br />2.不支持锁重入，不支持阻塞等待<br/>3.操作数据库开销大，性能不高 |
| 基于数据库         | 基于MongoDB findAndModify原子操作 | 1.加锁：执行findAndModify原子命令查找document，若不存在则新增<br/>2.解锁：删除document | 实现也很容易，较基于MySQL唯一索引的方案，性能要好很多        | 1.大部分公司数据库用MySQL，可能缺乏相应的MongoDB运维、开发人员<br/>2.锁无超时自动失效机制 |
| 基于分布式协调系统 | 基于ZooKeeper                     | 1.加锁：在/lock目录下创建临时有序节点，判断创建的节点序号是否最小。若是，则表示获取到锁；否，则则watch /lock目录下序号比自身小的前一个节点<br/>2.解锁：删除节点 | 1.由zk保障系统高可用<br/>2.Curator框架已原生支持系列分布式锁命令，使用简单 | 需单独维护一套zk集群，维保成本高                             |
| 基于缓存           | 基于redis命令                     | 1. 加锁：执行setnx，若成功再执行expire添加过期时间<br/>2. 解锁：执行delete命令 | 实现简单，相比数据库和分布式系统的实现，该方案最轻，性能最好 | 1.setnx和expire分2步执行，非原子操作；若setnx执行成功，但expire执行失败，就可能出现死锁<br/>2.delete命令存在误删除非当前线程持有的锁的可能<br/>3.不支持阻塞等待、不可重入 |
|                    | 基于redis Lua脚本能力             | 1. 加锁：执行SET lock_name random_value EX seconds NX 命令<br/><br/>2. 解锁：执行Lua脚本，释放锁时验证random_value <br/>-- ARGV[1]为random_value,  KEYS[1]为lock_name<br/>if redis.call("get", KEYS[1]) == ARGV[1] then<br/><br/>    return redis.call("del",KEYS[1])<br/><br/>else<br/><br/>    return 0<br/><br/>end | 同上；实现逻辑上也更严谨，除了单点问题，生产环境采用用这种方案，问题也不大。 | 不支持锁重入，不支持阻塞等待                                 |
|                    |                                   |                                                              |                                                              |                                                              |
|                    |                                   |                                                              |                                                              |                                                              |
|                    |                                   |                                                              |                                                              |                                                              |
|                    |                                   |                                                              |                                                              |                                                              |



### Redis与memcached相比有哪些优势

1、Redis支持更丰富的数据类型，memcached所有的值均为简单的字符串

2、redis速度比memcached快

3、redis可以持久化数据

### Mysql中有200w数据，redis中只能存储20w数据，如何保证redis中的数据都是热点数据。

Redis中的数据达到一定程度时，就会执行内存数据淘汰策略。

### Redis适合的场景

会话缓存
队列
排行榜/计数器
发布/订阅

### Jedis与Redis对比

Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；

Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为复杂，不仅支持字符串操作，且还支持排序、事务、管道、分区等Redis特性。

Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

### Redis的hash[槽](https://blog.csdn.net/tianyeshiye/article/details/79600014)

Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value



时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，

这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大

致均等的将哈希槽映射到不同的节点。

Redis 集群没有使用一致性hash, 而是引入了哈希槽的概念。

Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽。这种结构很容易添加或者删除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。

使用哈希槽的好处就在于可以方便的添加或移除节点。

当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；

当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；

在这一点上，我们以后新增或移除节点的时候不用先停掉所有的 redis 服务。

### Redis常见的性能问题和解决方案

1、Master最好不要写内存快照，如果master写内存快照,save命令调度rdbsave()函数,会阻塞主线程的工作。当快照较大时,对性能影响是比较大的。会间断性暂停服务。
2、如果数据比较重要，某个salve可以开启AOF备份数据,策略设置为每秒同步一次。
3、为了主从复制连接的稳定性，master和salve最好在同一个局域网中
4、尽量避免在压力很大的主库上面增加从库。

5、主从复制不要用网状结构,用单向链表结构更稳定。即master <-salve1 <-salve2 <-salve3 这样的结构方便解决单点故障,实现salve对mster的替换主从复制不要用网状结构,用单向链表结构更稳定。即master <-salve1 <-salve2 <-salve3 这样的结构方便解决单点故障,实现salve对mster的替换

### Redis同步机制

可以使用主从同步，从从同步，第一次同步时，主节点做一次bgsave,并同时将后续修改操作记录在内存中，待完成后将rdb文件全量同步到复制节点 复制节点接受完后将rdb镜像加载到内存中,加载完成后，在通知主节点将期间修改的操作记录同步到复制节点进行重放完成了同步过程

##### 传输的时候断网了怎么办

传输过程中有什么网络问题啥的，会自动重连的，并且连接之后会把缺少的数据补上的。

### Redis是如何进行回收工作

一个客户端运行新的命令,添加新的数据。redis检查内存的使用情况，如果大于maxmemory的限制，则根据设置好的策略进行回收。一个新命令被执行等等。所以我们不断地穿越内存的限制,通过不断的达到边界然后不断的回收到边界以下,如果一个命令导致大量内存被使用,不用多久内存限制就会被这个内存使用量超越

### Redis的发布订阅缺点

在消费者下线的情况下,生产者的消息会丢失，的使用专业的消息队列，如RabbitMQ等。

### Redis如何实现延时队列

采用sortedset结构，使用时间戳作为score,消息内容作为key调用zadd来进行消息的生产。消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理

我们可以使用 zset（sortedset）这个命令，用设置好的时间戳作为score进行排序，使用 zadd score1 value1 ....命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。也可以通过 zrangebyscore key min max withscores limit 0 1 查询最早的一条任务，来进行消费。

### Redis集群原理及写操作会有丢失吗？

Redis sentinal 着眼于高可用，当master宕机的情况下，将salve提升为master,继续对外提供服务

Redis Cluster着眼与扩展性,在单个Redis内存不足时，可以进行分片存储。




Redis集群不能保证数据的强一致性，意味着在某些特定的条件下，可能会丢失写操作

### Redis事务

事务是一个单独的隔离操作:事务中的所以命令都会序列化、按顺序执行.事务在执行的过程中,不会被其他客户端送来的命令打断。
事务是一个原子操作:事务中的命令要不全部执行要不全部不执行

### Redis为什么这么快

1、完全基于内存,绝大部分请求时纯粹的内存操作，非常快速

2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的

3、使用多路I/O复用模型，非阻塞IO

4、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；



