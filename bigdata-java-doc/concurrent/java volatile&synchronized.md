java volatile&synchronized

### Volatile

volatile是java定义的关键字之一，可以认为是轻量级的synchronized，但是并不能替代synchronized,它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能马上读到这个修改的值。

volatile相对于多线程，不是一种互斥关系，不能保证变量状态的“原子性操作。

volatile主要有两大作用：
1、保证线程的可见性，即保证多个线程对使用volatile修饰的变量可见，但是不能保证共同修改变量所带来的的不一致问题，即不能代替synchronized.
2、防止指令重排

```java
public class VolatileDemo1 {

    //当flag不是用volatile关键字修饰的时候 该程序不会退出
    public static volatile boolean flag = true;


    public static class taskThread extends Thread {

        public int i;

        public taskThread(String name) {
            super(name);
        }

        @Override
        public void run() {

            System.out.println(this.getName() + " 线程执行开始");

            while (flag) {
                ;
//                System.out.println("循环次数为 " + (i++))
            }
            System.out.println(this.getName() + " 线程执行结束");

        }
    }


    public static void main(String[] args) throws InterruptedException {
        new taskThread("task1").start();
        Thread.sleep(1000);
        flag = false;

    }


}
```

### synchronized

synchronized被称为重量级可重入锁，但JDK1.6对synchronized进行了各种优化已经变为了轻量级锁了。

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础。synchronized的使用方式主要是如下三种方式：
普通同步方法，锁是当前实例对象
静态同步方法，锁是当前类的class对象
同步方法块，锁是括号里面的对象

JVM规范中对于同步代码块，使用monitorenter和monitorexit实现的，monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

#### java对象头

jasynchronized用的锁是存在在java对象头里面，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头

非数组类型的对象头的结构如下图

![1647413941](.\pic\1647413941.png)

### 锁升级

Java SE1.6引入了偏向锁和轻量级锁，因此在1.6之后锁一共有如下四种状态，依次从低到高为 无锁状态—>偏向锁状态—>轻量级锁状态—>重量级锁状态，随着竞争情况的加剧而逐渐升级。锁可以升级但是不能降级，目的是为了提高获取锁和释放锁的效率。

#### 偏向锁的初始化流程

![1647415123](.\pic\1647415123.png)

1、线程1首先读取目标对象的MarkWord,检查对象头中是否存在线程1，如果没有此时会采用cas操作MarkWord将自己的线程 ID 写入MarkWord，此时操作成功则认为已经获取了该对象的偏向锁，并执行同步代码块。以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁

2、此时线程2读取目标对象的MarkWord,判断对象中存储的是否为线程2，发现不是则进行cas操作MarkWord，此时操作会失败，因为该对象目前是偏向线程1。此时需要撤销偏向锁。

3、偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

#### 轻量级锁到重量级锁过程

![1647417122](.\pic\1647417122.png)

在锁撤销后会进入无锁状态，此时线程1和线2会进入到竞争轻量级锁的状态，过程如下

1、线程1和线程2首先会分配空间并复制MarkWord到栈

2、线程1和线程2同时采用cas算法修改MarkWord替换为指向锁记录的指针，此时线程1修改成功，获取轻量级锁，执行同步代码块，而线程2修改失败，则尝试使用自旋获取锁。

3、线程2自旋获取锁失败，此时线程2修改MarkWord的标志位，锁膨胀为重量级锁，同时线程2进入到阻塞状态。同时线程1在执行完同步代码块后，会采用cas操作替换MarkWord,操作会失败，表示当前锁存在竞争，会进行释放锁并唤醒等待的线程2。

自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

#### 锁的优缺点

| 锁       | 有点                                                         | 缺点                                           | 使用场景                           |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间同步执行速度非常快     |
| 重量级锁 | 线程竞争不使用自旋，不消耗CPU                                | 线程阻塞，响应时间缓慢                         | 追求吞吐量，同步块执行速度较长     |

参考：java并发编程的艺术

https://blog.csdn.net/lengxiao1993/article/details/81568130